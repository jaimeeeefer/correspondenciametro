<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Correspondencia Metro Bilbao y Bizkaibus</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1 {
            color: #d10000; /* Color de Metro Bilbao */
            text-align: center;
            margin-bottom: 25px;
        }
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        input[type="text"],
        input[type="number"],
        select,
        button {
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #d10000;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #a00000;
        }
        .results-container {
            background-color: #e9e9e9;
            padding: 20px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            min-height: 150px;
            margin-top: 20px;
        }
        .direction-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .direction-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        h2 {
            color: #d10000;
            font-size: 20px;
            margin-top: 0;
            margin-bottom: 15px;
        }
        h3 {
            color: #007bff; /* Color para Bizkaibus */
            font-size: 18px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .train-info, .bus-info {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px 15px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column; /* Organiza la información en columnas */
            justify-content: space-between;
            align-items: flex-start; /* Alinea los elementos a la izquierda */
            font-size: 1em;
        }
        .train-info strong, .bus-info strong {
            color: #333;
            width: 100%; /* Ocupa todo el ancho */
            margin-bottom: 5px;
        }
        .train-info span, .bus-info span {
            color: #666;
            width: 100%; /* Ocupa todo el ancho */
            text-align: left; /* Alinea a la izquierda por defecto */
            margin-bottom: 3px; /* Espacio entre las líneas de información */
        }
        .train-info span:last-of-type {
            margin-bottom: 0; /* Sin margen inferior en el último span */
        }

        .train-info .correspondence-text {
            color: green;
            font-weight: bold;
            margin-left: 10px; /* Espacio a la izquierda del texto */
            white-space: nowrap; /* Evita que el texto se rompa */
        }
        .train-info .correspondencejusta-text {
            color: orange; /* Cambio a naranja para "Enlace justo" */
            font-weight: bold;
            margin-left: 10px;
            white-space: nowrap;
        }
        .bus-status-ontime {
            color: green;
            font-weight: bold;
        }
        .bus-status-early {
            color: #007bff; /* Azul para "Adelantado" */
            font-weight: bold;
        }
        .bus-status-late {
            color: red;
            font-weight: bold;
        }
        .bus-status-unknown {
            color: gray;
            font-weight: normal;
        }
        .no-results, .error-message {
            color: #d10000;
            font-weight: bold;
            text-align: center;
            padding: 10px;
        }
        .loading {
            text-align: center;
            font-size: 1.2em;
            color: #d10000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Correspondencia Metro Bilbao y Bizkaibus</h1>

        <div class="input-section">
            <label for="metroStationCode">Estación de Metro (Origen):</label>
            <input type="text" list="metroStationsList" id="metroStationCode" name="metroStationCode" placeholder="Escribe o selecciona una estación..." />
            <datalist id="metroStationsList"></datalist>

            <label for="bizkaibusDestinationStation">Parada de Bizkaibus (Destino):</label>
            <select id="bizkaibusDestinationStation" name="bizkaibusDestinationStation">
                <option value="POR">Portugalete (Carlos VII 18) - Parada 450</option>
                <option value="BAG">Bagatza (Av. Miranda 2) - Parada 411</option>
                <option value="GUR">Gurutzeta / Cruces (Horacio Etxebarrieta) - Parada 402</option>
            </select>

            <button onclick="displayNextArrivalsAndCorrespondence()">Mostrar Próximos Trenes y Buses</button>
        </div>

        <div class="results-container" id="metroResults">
            <p class="loading">Esperando selección de estación...</p>
        </div>

        <div class="results-container" id="bizkaibusResults">
            <p class="loading">Esperando selección de estación de Bizkaibus...</p>
        </div>
    </div>

    <script>
        let bizkaibusStopTimesData = [];
        let bizkaibusCalendarData = [];
        let bizkaibusCalendarDatesData = [];
        let bizkaibusTripsData = [];

        // Variable global para almacenar los datos en tiempo real de Bizkaibus
        let bizkaibusRealTimeData = [];
        let realTimeFetchInterval = null; // Para controlar el intervalo de actualización

        const metroStations = [
            { code: "PLE", name: "Plentzia" },
            { code: "URD", name: "Urduliz" },
            { code: "SOP", name: "Sopela" },
            { code: "LAR", name: "Larrabasterra" },
            { code: "BER", name: "Berango" },
            { code: "IBB", name: "Ibarbengoa" },
            { code: "BID", name: "Bidezabal" },
            { code: "ALG", name: "Algorta" },
            { code: "AIB", name: "Aiboa" },
            { code: "NEG", name: "Neguri" },
            { code: "GOB", name: "Gobela" },
            { code: "ARE", name: "Areeta" },
            { code: "LAM", name: "Lamiako" },
            { code: "LEI", name: "Leioa" },
            { code: "AST", name: "Astrabudua" },
            { code: "ERA", name: "Erandio" },
            { code: "LUT", name: "Lutxana" },
            { code: "KAB", name: "Kabiezes" },
            { code: "STZ", name: "Santurtzi" },
            { code: "PEN", name: "Peñota" },
            { code: "POR", name: "Portugalete" },
            { code: "ABT", name: "Abatxolo" },
            { code: "SES", name: "Sestao" },
            { code: "URB", name: "Urbinaga" },
            { code: "BAG", name: "Bagatza" },
            { code: "BAR", name: "Barakaldo" },
            { code: "ANS", name: "Ansio" },
            { code: "GUR", name: "Gurutzeta / Cruces" },
            { code: "SIN", name: "San Ignazio" },
            { code: "SAR", name: "Sarriko" },
            { code: "DEU", name: "Deustu" },
            { code: "SAM", name: "Santimami / San Mamés" },
            { code: "IND", name: "Indautxu" },
            { code: "MOY", name: "Moyua" },
            { code: "ABA", name: "Abando" },
            { code: "CAV", name: "Zazpikaleak / Casco Viejo" },
            { code: "SAN", name: "Santutxu" },
            { code: "BAS", name: "Basarrate" },
            { code: "BOL", name: "Bolueta" },
            { code: "ETX", name: "Etxebarri" },
            { code: "ARZ", name: "Ariz" },
            { code: "BSR", name: "Basauri" }
        ];

        // Mapeo de estaciones de Metro a paradas y líneas/destinos de Bizkaibus relevantes
        const bizkaibusCorrespondenceMap = {
            "POR": {
                stopId: '450',
                stopName: 'Carlos VII 18',
                lines: [{ routeId: 'A3333', headsigns: ['GALLARTA', 'LA ARBOLEDA'] }] // Línea A3333, destino "GALLARTA"
            },
            "BAG": {
                stopId: '411',
                stopName: 'Beurko (Av. Miranda 2)',
                lines: [{ routeId: 'A3338', headsigns: ['MUSKIZ', 'MUSKIZ La Arena'] }] // Línea A3338, destino "MUSKIZ La Arena"
            },
            "GUR": {
                stopId: '402',
                stopName: 'Cruces Ospitalea (Horacio Etxebarrieta)',
                lines: [{ routeId: 'A3336', headsigns: ['MUSKIZ', 'MUSKIZ La Arena', 'SOPUERTA'] }] // Línea A3336, destinos "MUSKIZ", "MUSKIZ La Arena" o "SOPUERTA"
            }
        };

        // URLs para los datos de Bizkaibus. Se usa stop_times2.txt para Bagatza y Gurutzeta.
        const bizkaibusStopTimesUrl = 'https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/refs/heads/main/stop_times2.txt';
        const bizkaibusCalendarUrl = 'https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/refs/heads/main/calendar.txt';
        const bizkaibusCalendarDatesUrl = 'https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/refs/heads/main/calendar_dates.txt';
        const bizkaibusTripsUrl = 'https://raw.githubusercontent.com/jaimeeeefer/bizkaibus/refs/heads/main/trips.txt';

        const metroBilbaoApiBaseUrl = 'https://api.metrobilbao.eus/metro/real-time';
        const bizkaibusRealTimeApiUrl = 'https://info-bizkaibus.jaimeferni10.workers.dev/'; // Nueva API para tiempo real

        // Función para poblar el desplegable de estaciones de Metro
        function populateMetroStationsDropdown() {
            const datalist = document.getElementById('metroStationsList');
            metroStations.forEach(station => {
                const option = document.createElement('option');
                option.value = `${station.name} (${station.code})`;
                datalist.appendChild(option);
            });
        }

        async function loadBizkaibusData() {
            try {
                // Fetch common Bizkaibus data (stop_times, calendar, trips) once
                const [stopTimesResponse, calendarResponse, calendarDatesResponse, tripsResponse] = await Promise.all([
                    fetch(bizkaibusStopTimesUrl),
                    fetch(bizkaibusCalendarUrl),
                    fetch(bizkaibusCalendarDatesUrl),
                    fetch(bizkaibusTripsUrl)
                ]);

                bizkaibusStopTimesData = parseCSV(await stopTimesResponse.text());
                bizkaibusCalendarData = parseCSV(await calendarResponse.text());
                bizkaibusCalendarDatesData = parseCSV(await calendarDatesResponse.text());
                bizkaibusTripsData = parseCSV(await tripsResponse.text());

                // Initial messages after loading common Bizkaibus data
                document.getElementById('metroResults').innerHTML = '<p style="text-align: center;">Datos de Bizkaibus cargados. Selecciona una estación de Metro para buscar.</p>';
                document.getElementById('bizkaibusResults').innerHTML = '<p style="text-align: center;">Datos de Bizkaibus cargados. Selecciona una parada de Bizkaibus para ver los autobuses.</p>';

            } catch (error) {
                console.error('Error loading static Bizkaibus data:', error);
                document.getElementById('metroResults').innerHTML = '<p class="error-message">Error al cargar datos estáticos de Bizkaibus. Inténtalo de nuevo más tarde.</p>';
                document.getElementById('bizkaibusResults').innerHTML = '<p class="error-message">Error al cargar datos estáticos de Bizkaibus.</p>';
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            return lines.slice(1).map(line => {
                const values = line.split(',');
                const row = {};
                headers.forEach((header, i) => {
                    row[header.trim()] = values[i] ? values[i].trim() : '';
                });
                return row;
            });
        }

        function getDayOfWeek(date) {
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            return days[date.getDay()];
        }

        function convertTimeToMinutes(timeStr) {
            if (typeof timeStr !== 'string' || timeStr.trim() === '') {
                console.warn('Invalid time string for convertTimeToMinutes:', timeStr);
                return NaN; // Return NaN for invalid input
            }
            const parts = timeStr.split(':').map(Number);
            // Ensure parts has at least 2 elements (hours, minutes)
            if (parts.length < 2) {
                console.warn('Time string format unexpected:', timeStr);
                return NaN;
            }
            const hours = parts[0];
            const minutes = parts[1];
            const seconds = parts[2] || 0;
            return (hours * 60) + minutes + (seconds / 60);
        }

        function formatMinutesToHHMM(minutesTotal) {
            if (isNaN(minutesTotal)) {
                return 'N/A';
            }
            const hours = Math.floor(minutesTotal / 60);
            const minutes = Math.round(minutesTotal % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        async function fetchAndProcessRealTimeBizkaibusData() {
            const bizkaibusSelection = document.getElementById('bizkaibusDestinationStation').value;
            // bizkaibusSelection ahora es el código de Metro (ej: "POR", "BAG", "GUR")
            const bizkaibusInfo = bizkaibusCorrespondenceMap[bizkaibusSelection];

            // LOG: Bizkaibus Info
            console.log('LOG: Bizkaibus Info:', bizkaibusInfo);

            const bizkaibusResultsContainer = document.getElementById('bizkaibusResults');

            if (!bizkaibusInfo) {
                bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus</h2><p class="error-message">Error: No se pudo encontrar la información para la parada seleccionada de Bizkaibus.</p>`;
                return;
            }

            bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2><p class="loading">Obteniendo datos en tiempo real...</p>`;

            try {
                const response = await fetch(bizkaibusRealTimeApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "application/xml");

                let vehicleActivities = xmlDoc.getElementsByTagName('VehicleActivity');
                bizkaibusRealTimeData = []; // Clear previous real-time data

                for (let i = 0; i < vehicleActivities.length; i++) {
                    const activity = vehicleActivities[i];
                    const tripIdElement = activity.getElementsByTagName('VehicleJourneyRef')[0];
                    const recordedAtTimeElement = activity.getElementsByTagName('RecordedAtTime')[0];
                    const monitoredCallElement = activity.getElementsByTagName('MonitoredCall')[0];

                    if (tripIdElement && recordedAtTimeElement && monitoredCallElement) {
                        const tripId = tripIdElement.textContent;
                        const recordedAtTimeStr = recordedAtTimeElement.textContent;
                        const stopPointRefElement = monitoredCallElement.getElementsByTagName('StopPointRef')[0];
                        const arrivalStatusElement = monitoredCallElement.getElementsByTagName('ArrivalStatus')[0];
                        
                        // NEW: Extract route from trip_id for real-time data as well
                        let routeIdFromTripId = null;
                        const match = tripId.match(/trp_([A-Za-z0-9]+)_/);
                        if (match && match[1]) {
                            routeIdFromTripId = match[1];
                        }
                        
                        if (stopPointRefElement && arrivalStatusElement && routeIdFromTripId) {
                            bizkaibusRealTimeData.push({
                                tripId: tripId,
                                routeId: routeIdFromTripId, // Use the extracted routeId
                                recordedAtTime: new Date(recordedAtTimeStr),
                                stopPointRef: stopPointRefElement.textContent, // The stop where it was recorded
                                arrivalStatus: arrivalStatusElement.textContent
                            });
                        }
                    }
                }
                // Trigger re-display to update with real-time data
                displayNextArrivalsAndCorrespondence(true); // Call with false to avoid re-fetching Metro data
            } catch (error) {
                console.error('Error fetching real-time Bizkaibus data:', error);
                bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2><p class="error-message">Error al cargar datos en tiempo real: ${error.message}</p>`;
            }
        }

        async function displayNextArrivalsAndCorrespondence(fetchMetroData = true) {
            const stationInput = document.getElementById('metroStationCode').value.trim();
            const match = stationInput.match(/\((\w+)\)$/);
            const metroStationCode = match ? match[1] : null;

            const bizkaibusSelection = document.getElementById('bizkaibusDestinationStation').value;
            // bizkaibusSelection ahora es el código de Metro (ej: "POR", "BAG", "GUR")
            const bizkaibusInfo = bizkaibusCorrespondenceMap[bizkaibusSelection];

            if (!bizkaibusInfo) {
                document.getElementById('bizkaibusResults').innerHTML = `<h2>Próximos autobuses Bizkaibus</h2><p class="error-message">Error: No se pudo encontrar la información para la parada seleccionada de Bizkaibus.</p>`;
                return;
            }

            // El código de destino de Metro es la clave de la selección de Bizkaibus
            const metroDestinationCode = bizkaibusSelection; 

            const metroResultsContainer = document.getElementById('metroResults');
            const bizkaibusResultsContainer = document.getElementById('bizkaibusResults');

            if (fetchMetroData) {
                metroResultsContainer.innerHTML = '<p class="loading">Buscando trenes de Metro Bilbao...</p>';
            }
            bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2><p class="loading">Cargando autobuses Bizkaibus...</p>`;

            if (!metroStationCode) {
                metroResultsContainer.innerHTML = '<p class="error-message">Por favor, escribe o selecciona una estación de Metro válida.</p>';
                bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2><p class="loading">Esperando selección de estación de Metro.</p>`;
                return;
            }

            if (metroStationCode === metroDestinationCode) {
                metroResultsContainer.innerHTML = `<p class="error-message">La estación de origen (${metroStationCode}) no puede ser la misma que la estación de destino (${metroDestinationCode}). Por favor, selecciona otra estación de origen.</p>`;
                bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2><p class="loading">Corrige la estación de Metro de origen.</p>`;
                return;
            }

            const now = new Date();
            const currentDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const currentTimeInMinutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;

            let metroBilbaoTrains = [];
            if (fetchMetroData) {
                try {
                    const metroApiUrl = `${metroBilbaoApiBaseUrl}/${metroStationCode}/${metroDestinationCode}`;
                    const response = await fetch(metroApiUrl);
                    if (!response.ok) {
                        // Log more details about the HTTP error
                        console.error(`Metro Bilbao API HTTP Error: Status ${response.status}, URL: ${metroApiUrl}`);
                        metroBilbaoTrains = [];
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    if (data && Array.isArray(data.trains) && data.trip) {
                        const tripDurationMinutes = data.trip.duration;
                        const tripLine = data.trip.line;
                        const tripToStationName = data.trip.toStation.name;
                        const originStationName = metroStations.find(s => s.code === metroStationCode)?.name || metroStationCode;

                        metroBilbaoTrains = data.trains.map(train => {
                            const departureTimeFromOriginMinutes = convertTimeToMinutes(train.timeRounded);
                            const arrivalTimeAtDestinationMinutes = departureTimeFromOriginMinutes + tripDurationMinutes;

                            return {
                                departureTimeFromOrigin: train.timeRounded,
                                arrivalTimeAtDestination: formatMinutesToHHMM(arrivalTimeAtDestinationMinutes),
                                line: tripLine,
                                destination: tripToStationName,
                                timeToArrivalAtDestination: arrivalTimeAtDestinationMinutes - currentTimeInMinutes,
                                arrivalTimeAtDestinationMinutes: arrivalTimeAtDestinationMinutes
                            };
                        });
                    } else {
                        // Log the unexpected data structure
                        console.error('Metro Bilbao API response unexpected or empty trains array:', data);
                        metroResultsContainer.innerHTML = '<p class="no-results">Formato de respuesta de Metro Bilbao inesperado o no se encontraron trenes. Por favor, inténtalo de nuevo más tarde.</p>';
                        metroBilbaoTrains = [];
                    }

                } catch (error) {
                    console.error('Error fetching Metro Bilbao data:', error);
                    const originStationNameForDisplay = metroStations.find(s => s.code === metroStationCode)?.name || metroStationCode;
                    const destinationStationNameForDisplay = metroStations.find(s => s.code === metroDestinationCode)?.name || metroDestinationCode;
                    metroResultsContainer.innerHTML = `<p class="error-message">Error al obtener datos de Metro Bilbao para ${originStationNameForDisplay} a ${destinationStationNameForDisplay}. (${error.message}). Por favor, verifica tu selección e inténtalo de nuevo.</p>`;
                    metroBilbaoTrains = [];
                }
            }

            // --- Calculate Bizkaibus data for correspondence check ---
            const activeServiceIdsBizkaibus = getServiceIdsForDate(currentDay, bizkaibusCalendarData, bizkaibusCalendarDatesData);

            const stopTimesAtBizkaibusStation = bizkaibusStopTimesData.filter(st => st.stop_id === bizkaibusInfo.stopId);

            const relevantBizkaibusTrips = bizkaibusTripsData.filter(trip => activeServiceIdsBizkaibus.has(trip.service_id));
            const tripIdsWithServiceBizkaibus = new Set(relevantBizkaibusTrips.map(trip => trip.trip_id));

            const filteredBizkaibusStopTimes = stopTimesAtBizkaibusStation.filter(st => tripIdsWithServiceBizkaibus.has(st.trip_id));

            const bizkaibusDepartures = [];
            filteredBizkaibusStopTimes.forEach(stopTime => {
                const departureTimeInMinutes = convertTimeToMinutes(stopTime.departure_time);

                let actualDepartureTimeInMinutes = departureTimeInMinutes;
                // Handling times past 24:00 for the current day
                if (departureTimeInMinutes >= 24 * 60) {
                    actualDepartureTimeInMinutes -= 24 * 60;
                }

                let timeDifference = departureTimeInMinutes - currentTimeInMinutes;

                // Adjust for overnight services (e.g., if current time is late at night and bus departs early next morning)
                if (timeDifference < 0 && departureTimeInMinutes < 4 * 60 && currentTimeInMinutes > 20 * 60) {
                     timeDifference += 24 * 60;
                }

                if (timeDifference >= -5) {
                    const trip = bizkaibusTripsData.find(t => t.trip_id === stopTime.trip_id);
                    if (trip) {
                        const busHeadsign = stopTime.stop_headsign || trip.trip_headsign || 'Desconocido';
                        
                        // NEW LOGIC: Extract route from trip_id string
                        let extractedRouteId = 'Desconocido';
                        const matchTripId = stopTime.trip_id.match(/trp_([A-Za-z0-9]+)_/); // e.g., extracts A3333 from trp_A3333_...
                        if (matchTripId && matchTripId[1]) {
                            extractedRouteId = matchTripId[1];
                        }
                        // console.log(`  LOG: Extracted Route ID from trip_id "${stopTime.trip_id}": "${extractedRouteId}"`);

                        bizkaibusDepartures.push({
                            departureTime: stopTime.departure_time,
                            departureTimeInMinutes: departureTimeInMinutes,
                            timeToDeparture: timeDifference,
                            headsign: busHeadsign,
                            tripId: stopTime.trip_id,
                            routeId: extractedRouteId // Use the extracted Route ID here
                        });
                        // console.log(`  LOG: Populating BizkaibusDeparture - Trip ID: ${stopTime.trip_id}, Extracted Route ID: ${extractedRouteId}, stopTime.stop_headsign: "${stopTime.stop_headsign}", trip.trip_headsign: "${trip.trip_headsign}", Final headsign property: "${busHeadsign}"`);
                    }
                }
            });

            // --- NEW: Filter bizkaibusDepartures based on lines and headsigns defined in bizkaibusCorrespondenceMap ---
            const relevantBizkaibusLines = bizkaibusInfo.lines;
            let filteredBizkaibusDepartures = bizkaibusDepartures.filter(bus => {
                // Return true if the bus should be included, false otherwise.
                // The 'some' method checks if any configLine satisfies the condition.
                return relevantBizkaibusLines.some(configLine => {
                    const routeMatches = bus.routeId === configLine.routeId; // Now bus.routeId comes from extracted part of trip_id
                    const headsignMatches = configLine.headsigns.some(hs => bus.headsign.toLowerCase().includes(hs.toLowerCase()));

                    return routeMatches && headsignMatches;
                });
            });
            // LOG: Filtered Bizkaibus Departures (after line/headsign filter) - This is the correct list for correspondence
            console.log('LOG: Filtered Bizkaibus Departures for correspondence:', filteredBizkaibusDepartures);
            // Precalcular delayMinutes y hora estimada para cada bus
            filteredBizkaibusDepartures.forEach(bus => {
                const realTimeBus = bizkaibusRealTimeData.find(rt =>
                    rt.tripId === bus.tripId && rt.routeId === bus.routeId
                );

                if (realTimeBus) {
                    const theoreticalStopTimeEntry = bizkaibusStopTimesData.find(st =>
                        st.trip_id === realTimeBus.tripId && st.stop_id === realTimeBus.stopPointRef
                    );

                    if (theoreticalStopTimeEntry) {
                        const stopsForTrip = bizkaibusStopTimesData.filter(st => st.trip_id === realTimeBus.tripId);

                        // Buscar la primera parada (stop_sequence === '1')
                        const originStop = stopsForTrip.find(st => st.stop_sequence === '1');

                        if (originStop) {
                            const originTimeStr = originStop.departure_time;
                            const [h, m, s] = originTimeStr.split(':').map(Number);
                            const originTime = new Date(realTimeBus.recordedAtTime);
                            
                            if (h >= 24) {
                                originTime.setDate(originTime.getDate() + 1);
                            }
                            originTime.setHours(h % 24, m, s || 0, 0);

                            const now = realTimeBus.recordedAtTime;
                            const diffMinutes = (now - originTime) / 60000;

                            // Solo calculamos delay si ya ha salido de la parada de origen
                            if (diffMinutes >= 0) {
                                const theoreticalTimeStr = theoreticalStopTimeEntry.departure_time;
                                const theoreticalDate = new Date(now);
                                let [ht, mt, st_] = theoreticalTimeStr.split(':').map(Number);
                                if (ht >= 24) {
                                    theoreticalDate.setDate(theoreticalDate.getDate() + 1);
                                }
                                theoreticalDate.setHours(ht % 24, mt, st_ || 0, 0);

                                let delayMinutes = (now - theoreticalDate) / 60000;

                                if (delayMinutes > 720) delayMinutes -= 1440;
                                if (delayMinutes < -720) delayMinutes += 1440;

                                bus.delayMinutes = delayMinutes;

                                const baseMinutes = convertTimeToMinutes(bus.departureTime.split(':').slice(0, 2).join(':'));
                                bus.estimatedDepartureMinutes = baseMinutes + delayMinutes;
                            } else {
                                // Aún no ha salido del origen, mostrar en hora
                                bus.delayMinutes = 0;
                                const baseMinutes = convertTimeToMinutes(bus.departureTime.split(':').slice(0, 2).join(':'));
                                bus.estimatedDepartureMinutes = baseMinutes;
                            }
                        }
                    }
                } else {
                    // Si no hay tiempo real, usar hora teórica como estimada
                    const baseMinutes = convertTimeToMinutes(bus.departureTime.split(':').slice(0, 2).join(':'));
                    bus.estimatedDepartureMinutes = baseMinutes;
                }
            });

            // Ordenar salidas por hora teórica (sin importar cuántos destinos haya)
            filteredBizkaibusDepartures.sort((a, b) => {
                return a.departureTimeInMinutes - b.departureTimeInMinutes;
            });

            // Eliminar buses que ya han salido (con adelanto incluido)
            filteredBizkaibusDepartures = filteredBizkaibusDepartures.filter(bus => {
                const cleanTime = bus.departureTime.split(':').slice(0, 2).join(':');
                let estimatedMinutes = convertTimeToMinutes(cleanTime);
                if (bus.delayMinutes !== undefined) {
                    estimatedMinutes += bus.delayMinutes;
                }
                return estimatedMinutes >= currentTimeInMinutes - 0.5;
            });

            // --- Display Metro Bilbao results with correspondence ---
            const originStationNameForDisplay = metroStations.find(s => s.code === metroStationCode)?.name || metroStationCode;
            const destinationStationNameForDisplay = metroStations.find(s => s.code === metroDestinationCode)?.name || metroDestinationCode;

            if (metroBilbaoTrains.length > 0) {
                metroResultsContainer.innerHTML = `<h2>Próximos trenes de Metro Bilbao desde ${originStationNameForDisplay} hacia ${destinationStationNameForDisplay}</h2>`;
                const sortedMetroTrains = metroBilbaoTrains.sort((a, b) => a.timeToArrivalAtDestination - b.timeToArrivalAtDestination);

                sortedMetroTrains.forEach(train => {
                    if (train.timeToArrivalAtDestination >= -5) {
                        const trainInfoDiv = document.createElement('div');
                        trainInfoDiv.classList.add('train-info');

                        let correspondenceMessage = '';
                        // NOW USE filteredBizkaibusDepartures for the correspondence check
                        const hasCorrespondence = filteredBizkaibusDepartures.some(bus => {
                            const cleanBusTime = bus.departureTime.split(':').slice(0, 2).join(':');
                            let estimatedBusTime = convertTimeToMinutes(cleanBusTime);
                            if (typeof bus.delayMinutes === 'number') {
                                estimatedBusTime += bus.delayMinutes;
                            }

                            // ❌ Si el tren llega después del bus estimado, no hay enlace
                            if (train.arrivalTimeAtDestinationMinutes > estimatedBusTime) {
                                return false;
                            }

                            const timeDifferenceMetroBus = estimatedBusTime - train.arrivalTimeAtDestinationMinutes;

                            if (timeDifferenceMetroBus > 2 && timeDifferenceMetroBus <= 10) {
                                correspondenceMessage = `<span class="correspondence-text">Enlace</span>`;
                                return true;
                            } else if (timeDifferenceMetroBus >= 0.5 && timeDifferenceMetroBus <= 2) {
                                correspondenceMessage = `<span class="correspondencejusta-text">Enlace justo</span>`;
                                return true;
                            } else if (timeDifferenceMetroBus > 10 && timeDifferenceMetroBus <= 15) {
                                correspondenceMessage = `<span class="correspondence-text">Enlace largo</span>`;
                                return true;
                            }

                            return false;
                        });

                        trainInfoDiv.innerHTML = `
                            <strong>Línea ${train.line} hacia ${train.destination}</strong>
                            <span>Salida de ${originStationNameForDisplay}: ${train.departureTimeFromOrigin}</span>
                            <span>Llegada a ${destinationStationNameForDisplay}: ${train.arrivalTimeAtDestination} (en ${formatTime(train.timeToArrivalAtDestination, train.departureTimeFromOrigin)}) ${correspondenceMessage}</span>
                        `;
                        metroResultsContainer.appendChild(trainInfoDiv);
                    }
                });
            } else {
                metroResultsContainer.innerHTML = `<h2>Próximos trenes de Metro Bilbao desde ${originStationNameForDisplay} hacia ${destinationStationNameForDisplay}</h2><p class="no-results">No se encontraron trenes próximos para esta ruta de Metro Bilbao.</p>`;
            }

            // --- Display Bizkaibus data with real-time status ---
            bizkaibusResultsContainer.innerHTML = `<h2>Próximos autobuses Bizkaibus (Parada ${bizkaibusInfo.stopId} - ${bizkaibusInfo.stopName})</h2>`;

            // Note: filteredBizkaibusDepartures is already correctly sorted by time and filtered by line/headsign
            // The display for Bizkaibus will now just use the already filtered and sorted list.

            if (filteredBizkaibusDepartures.length === 0) { // <--- USE filteredBizkaibusDepartures here too
                bizkaibusResultsContainer.innerHTML += `<p class="no-results">No se encontraron autobuses Bizkaibus próximos para la parada ${bizkaibusInfo.stopId} y los destinos configurados.</p>`;
            } else {

                const now = new Date();
                const nowInMinutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;

                // ✅ Filtrar los buses que aún no han salido (o como mucho hace 1 minuto)
                const nextRelevantBizkaibus = filteredBizkaibusDepartures
                    .filter(bus => {
                        if (typeof bus.estimatedDepartureMinutes !== 'number' || isNaN(bus.estimatedDepartureMinutes)) return true;
                        return bus.estimatedDepartureMinutes >= nowInMinutes - 1;
                    })
                    .slice(0, 5);

                // ✅ Pintar los buses filtrados
                nextRelevantBizkaibus.forEach(bus => {
                    const busInfoDiv = document.createElement('div');
                    busInfoDiv.classList.add('bus-info');

                    let realTimeStatus = '';
                    if (typeof bus.delayMinutes === 'number') {
                        if (Math.abs(bus.delayMinutes) <= 2.5) {
                            realTimeStatus = `<span class="bus-status-ontime">En hora</span>`;
                        } else if (bus.delayMinutes > 2.5) {
                            realTimeStatus = `<span class="bus-status-late">Retrasado por ${Math.round(bus.delayMinutes)} min.</span>`;
                        } else {
                            realTimeStatus = `<span class="bus-status-early">Adelantado por ${Math.round(Math.abs(bus.delayMinutes))} min.</span>`;
                        }
                    } else {
                        realTimeStatus = `<span class="bus-status-unknown">Sin datos en tiempo real (teórico)</span>`;
                    }
                    const realTimeBus = bizkaibusRealTimeData.find(rt => rt.tripId === bus.tripId && rt.routeId === bus.routeId);

                    // Calcular la hora estimada para mostrar
                    const baseMinutes = convertTimeToMinutes(bus.departureTime.split(':').slice(0, 2).join(':'));
                    const estimatedMinutes = bus.delayMinutes !== undefined ? baseMinutes + bus.delayMinutes : baseMinutes;
                    const estimatedTimeHHMM = formatMinutesToHHMM(estimatedMinutes);

                    // Calcular tiempo hasta salida
                    const timeToDeparture = estimatedMinutes - nowInMinutes;

                    busInfoDiv.innerHTML = `
                        <strong>Bizkaibus ${bus.routeId} hacia ${bus.headsign}</strong>
                        <span>Salida: ${bus.departureTime} (en ${formatTime(timeToDeparture)}) (aprox. ${estimatedTimeHHMM})</span>
                        <span>Estado: ${realTimeStatus}</span>
                    `;

                    bizkaibusResultsContainer.appendChild(busInfoDiv);
                });
            }
        }

        function getServiceIdsForDate(date, calendar, calendarDates) {
            const yyyymmdd = date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
            const dayOfWeek = getDayOfWeek(date);

            const activeServiceIds = new Set();

            calendar.forEach(service => {
                if (parseInt(service.start_date) <= yyyymmdd && parseInt(service.end_date) >= yyyymmdd) {
                    if (service[dayOfWeek] === '1') {
                        activeServiceIds.add(service.service_id);
                    }
                }
            });

            calendarDates.forEach(exception => {
                if (parseInt(exception.date) === yyyymmdd) {
                    if (exception.exception_type === '1') { // Service added
                        activeServiceIds.add(exception.service_id);
                    } else if (exception.exception_type === '2') { // Service removed
                        activeServiceIds.delete(exception.service_id);
                    }
                }
            });
            return activeServiceIds;
        }

        function formatTime(timeEstimated, timeRounded) {
            const formatMinutesToText = (minutes) => {
                if (minutes < -2) {
                    return 'Pasado';
                } else if (minutes <= 0) {
                    return 'En parada'; // Cambiado de 'Llegada'
                } else if (minutes === 1) {
                    return '1 minuto';
                } else if (minutes < 60) {
                    return `${Math.round(minutes)} minutos`;
                } else {
                    const hours = Math.floor(minutes / 60);
                    const remainingMinutes = Math.round(minutes % 60);
                    return `${hours}h ${remainingMinutes}min`;
                }
            };

            const estimatedText = formatMinutesToText(timeEstimated);

            let displayRoundedTime = 'N/A';
            // Se asegura que timeRounded sea una cadena antes de intentar procesarla
            if (typeof timeRounded === 'string' && timeRounded.trim() !== '') {
                const parts = timeRounded.split(':');
                if (parts.length === 3) { // Si el formato es HH:MM:SS
                    const totalMinutes = convertTimeToMinutes(timeRounded);
                    displayRoundedTime = formatMinutesToHHMM(totalMinutes);
                } else { // Asume que ya está en HH:MM o no necesita redondeo
                    displayRoundedTime = timeRounded.trim();
                }
            }

            return `${estimatedText}`;
        }

        // Manejo de la carga inicial y actualizaciones en tiempo real
        document.addEventListener('DOMContentLoaded', () => {
            populateMetroStationsDropdown();
            
            loadBizkaibusData().then(() => {
                // Configura la actualización en tiempo real de Bizkaibus
                // Llama inmediatamente para la parada por defecto y luego cada 30 segundos
                if (realTimeFetchInterval) {
                    clearInterval(realTimeFetchInterval);
                }
                fetchAndProcessRealTimeBizkaibusData(); 
                realTimeFetchInterval = setInterval(fetchAndProcessRealTimeBizkaibusData, 30000); 

                // Configura el listener para cambios en la selección de parada de Bizkaibus
                document.getElementById('bizkaibusDestinationStation').addEventListener('change', () => {
                    // Limpia cualquier intervalo existente
                    if (realTimeFetchInterval) {
                        clearInterval(realTimeFetchInterval);
                    }
                    // Obtiene y muestra los datos inmediatamente para la nueva selección
                    fetchAndProcessRealTimeBizkaibusData();
                    // Establece un nuevo intervalo para la nueva selección
                    realTimeFetchInterval = setInterval(fetchAndProcessRealTimeBizkaibusData, 30000);
                });
            });
        });
    </script>
</body>
</html>

